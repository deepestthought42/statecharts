* statecharts paper 
#+INTERLEAVE_PDF: statechart-paper.pdf
- statecharts is designed to describe a reactive system 

- states and events are /a priori/ a natural medium for describing the dynamic behaviour of
  a complex system

- statecharts main advantage: not all combinations of states have to be represented
  explicitly

- states can be clustered in a superstate
- states can be orhtogonal (or independent)
- states can be refined

** technical summary of statecharts
Statecharts is the extension of conventional state diagrams by AND/OR decomposition of
states together with inter-level transitions, and a broadcast mechanism for communication
between concurrent components.

/statecharts = state-diagrams + depth + orthogonality + broadcast-cummunication/
* Chart elements
** Arrow
Represents a state change upon receiving an event that is used to label the arrow.
** 
* Things to think about
** TODO how to manage broadcasts
Specifically: How to manage the order of broadcasts.

** TODO different entries into different states
let's go through this by the different kinds of states --> actually, this should be a
problem when having flattened the graph

** TODO event triggers a transition from every state
* Definitions 
** System
A regularly interacting or interdependent group of items forming a unified whole [fn:1].
** State 
<<state>> The state of a system is defined by the value of the variables that describe the
system.
** Event
We use the physical definition of an event: an event is the instantaneous physical
situation or occurrence associated with a point in spacetime (that is, a specific place
and time). A state transition is explicity defined as an event. 
** Transition
A change of state.

** reactive system
<<reactive>> As opposed to a transformational system, a reactive system is characterized
by being event driven, continuously having to react to external and internal stimuli.
 
Behaviour of a reactive system is the set of allowed seuences of input and output events,
conditions, actions, and additional information such as timing constraints.

* Implementation 
** ideas floating
*** for C backend: use plain enums
*** write backend independent binary format
- protobuf ?
** redoing how I define a statechart with a DSL
first thing to come up with, elements of the DSL
*** Elements of the DSL
- [ ] leaf state :: inidicated by :state, :s, :st
- [ ] orthogonal state :: indicated by :p, :orth, :orthogonal, :and, :.
- [ ] cluster :: indicated by :or, :c, :cluster, :+
- [ ] transition :: indicated by :t, :->, :trans, :transition
- [ ] condition :: indicated by :if, :given, :when
- [ ] actions :: indicated by :on-entry, :on-exit, :
* development logbook
** [2018-02-23 Fri 21:22] associate actions w/transitions instead of w/states
- first thing: find where two statenames differ
#+BEGIN_SRC lisp
(in-package #:statecharts)


(defstatechart (test-states)
  (c "test" (d "X")
    (c "X" (d "A")
      (s "A"  :entry (sc:act "adf" () (format t "Yes")))
      (s "B")
      (-> "alpha" "A" "B")
      (-> "beta" "B" "A"))
    (c "Y" (d "A")
      (s "A")
      (s "B")
      (-> "alpha" "B" "A"))
    (c "Z" (d "A")
      (s "A")
      (s "B"))
    (-> "gamma" "Y" "X")))


(create-fsm-runtime test-states)
#+END_SRC
** [2018-04-12 Thu 20:15] changed stuff, but now I don't know what is going on
   - ok, need to go through all my types and add a copy-obj method since
     I am just widely copying stuff now
   - have to think about what that means for function objects
   - might be best to store symbols instead of objects and then grab
     (via symbol-function) the function object when constructing the
     fsm
* TODOs 
** TODO guard against two substates with the same name
** DONE write function to parse conditionals 
** DONE given the transitions for an event, create cond to final state mapping
** DONE how to describe what to do upon max no of reentries ?
   *A*: implement this as a conditional using a mehtod on the environment: no-of-reentries

** DONE keep track of no of reentries
- incr. when reentry
- set to zero when exit

** DONE for transitions with reentry, find the correct actions to execute
** TODO implement history states
   - easiest way (at least conceptually) :: add a state that fires an event to the
     last state
   - the keep up order of events, make sure that history events have highest
     priority (i.e. get executed before anything else) 
   - first idea for keep priority of history events highest :: separate queue
   - I have a vague intuition that there might be a different solution
     where every cluster has a "shadow" cluster keeping track of the
     history, but the other option seems to be a lot easier and as
     long as it is not prohibitive in terms of performance ...
   - actually, could just introduce a transition with a clause for
     every substate, certainly the easiest to implement (maybe a bit
     slower for a dynamic runtime, but for performance critical
     writing static code is probably called for anyways)
   - I might still need a separate queue for this, though
** what is needed for the transition object
   - easiest might be to keep a history for every transition the
     content of which can only be the states that can be reached, so
     we can branch on that
   - since we know the initial state fsm state as well, we can
     completely determine the next fsm state when keeping it with the
     transitions based on initial and final state
   - so what we need is to set the history for the transition when
     exiting the final states associated with it
   - each transition gets a seperate history so when exiting the fsm
     state the histories need to be set
   - this can be done by just adding exit actions to the fsm after
     determining the final state of the transition
   - setting the history means changing the final state of the target
   - how do I mark history states when resolving partial states ?
** TODO improve performance
   we spent most of the time (at the moment) comparing states; so the
   first thing to improve perfermonce should be to shorten down the
   amount of time it takes to compare two states.

   *** idea: come up with a unique number for each state
   - OR states are unique, so we can just substates can be unrolled
   - AND states will need a sublist and an indicator which of the
     substates are included
     - the list will include NIL for substates that are not included
     - this means upon creation we need to know the total number of
       sub-states from the chart
* Footnotes

[fn:1] https://www.merriam-webster.com/dictionary/system

